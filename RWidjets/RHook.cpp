// RHook.cpp: implementation of the CRHook class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RHook.h"

extern LRESULT CALLBACK EscHook(int code, WPARAM wp, LPARAM lp);

/////////////////////////////////////////////////////////////////////////////
BEGIN_BL_METH_MAP(CRHook) 
    RBL_METH(Set,			"Установить",				2,	DefaultValue)
	//.<destination>
	//.Включает, выключает режим выполнения скрипта при уничтожении экземпляра объекта.
	//.<syntax>
	//.Установить(пРежим, пСкрипт);
	//.<return>
	//.Режим до выполнения метода.
	//.<param>
		//.<@name>пРежим
		//.<@destination>1 - включить выполнение скрипта, 0 - выключить
		//.<@optional>1
		//.<@type>Число
		//.<@default>
		//.<@values>
	//.<param>
		//.<@name>пСкрипт
		//.<@destination>Текст скрипта, выполняющегося в момент уничтожения экземпляра объекта.
		//.<@optional>1
		//.<@type>Строка
		//.<@default>Пустая строка
		//.<@values>
		//.<descr>
		//.В момент уничтожения экземпляра объекта (при выходе из зоны видимости локальной переменной, прерывании работы модуля)
		//.выполняется указанный скрипт. Скрипт пишется на внутреннем языке 1С. Скрипт выполняется в локальном контексте.
		//.Или в глобальном контексте, если работа локального модуля завершается. Другими словами, при уничтожении переменной модуля.
//.<sample>Процедура Сформировать()
//.<sample>	лХук=СоздатьОбъект("RHook");
//.<sample>	лХук.Установить(1, "Предупреждение(""Работа модуля прервана в цикле 1."");");
//.<sample>	// цикл 1
//.<sample>	Для А=1 По 10000 Цикл
//.<sample>		Состояние("Цикл 1");
//.<sample>	КонецЦикла;
//.<sample>	лХук.Скрипт("глПриУничтоженииПеременной()");
//.<sample>	// цикл 2
//.<sample>	Для А=1 По 10000 Цикл
//.<sample>		Состояние("Цикл 2");
//.<sample>	КонецЦикла;
//.<sample>	лХук.Установить(0);
//.<sample>КонецПроцедуры
//.<sample>// процедура глобального контекста
//.<sample>Процедура глПриУничтоженииПеременной()
//.<sample>	Предупреждение("Работа модуля прервана в цикле 2.");
//.<sample>КонецПроцедуры

    RBL_METH(Script,		"Скрипт",					1,	NULL)
	//.<destination>Устанавливает текст скрипта
	//.<syntax>
	//.Скрипт(пСкрипт);
	//.<return>
	//.Текст скрипта до выполнения метода.
	//.<param>
		//.<@name>пСкрипт
		//.<@destination>Текст скрипта, выполняющегося в момент уничтожения экземпляра объекта.
		//.<@optional>1
		//.<@type>Строка
		//.<@default>Пустая строка
		//.<@values>
		//.В момент уничтожения экземпляра объекта (при выходе из зоны видимости локальной переменной, прерывании работы модуля)
		//.выполняется указанный скрипт. Скрипт пишется на внутреннем языке 1С. Скрипт выполняется в глобальном контексте 
//.<sample>Процедура Сформировать()
//.<sample>	лХук=СоздатьОбъект("RHook");
//.<sample>	лХук.Установить(1, "Предупреждение(""Работа модуля прервана в цикле 1."");");
//.<sample>	// цикл 1
//.<sample>	Для А=1 По 10000 Цикл
//.<sample>		Состояние("Цикл 1");
//.<sample>	КонецЦикла;
//.<sample>	лХук.Скрипт("глПриУничтоженииПеременной()");
//.<sample>	// цикл 2
//.<sample>	Для А=1 По 10000 Цикл
//.<sample>		Состояние("Цикл 2");
//.<sample>	КонецЦикла;
//.<sample>	лХук.Установить(0);
//.<sample>КонецПроцедуры
//.<sample>// процедура глобального контекста
//.<sample>Процедура глПриУничтоженииПеременной()
//.<sample>	Предупреждение("Работа модуля прервана в цикле 2.");
//.<sample>КонецПроцедуры

    RBL_METH(SetHookEsc,	"УстановитьПерехват",	1,	DefaultValue)
	//.<destination>Включает, выключает перехват нажатия кнопки Esc
	//.<syntax>
	//.УстановитьПерехватЭскейп(пРежим);
	//.<return>
	//.Режим до выполнения метода.
	//.<param>
	  //.<@name>пРежим
	  //.<@destination>1 - включить перехват, 0 - выключить
	  //.<@optional>1
	  //.<@type>Число
	  //.<@default>
	  //.<@values>
	//.<descr>
	//.Включение перехвата не позволяет пользователю прервать выполнение модуля нажатием кнопки Esc. Во всех других режимах кнопка работает по-прежнему.
//.<sample>Процедура Сформировать()
//.<sample>	лХук=СоздатьОбъект("RHook");
//.<sample>	лХук.УстановитьПерехватЭскейп(1);
//.<sample>	// пользователь не сможет прервать выполнение этого цикла
//.<sample>	Для А=1 По 20000 Цикл
//.<sample>		Состояние("Цикл 1");
//.<sample>	КонецЦикла;
//.<sample>	лХук.УстановитьПерехватЭскейп(0);
//.<sample>	// а этого сможет
//.<sample>	Для А=1 По 20000 Цикл
//.<sample>		Состояние("Цикл 2");
//.<sample>	КонецЦикла;
//.<sample>КонецПроцедуры


END_BL_METH_MAP() 

BEGIN_BL_PROP_MAP(CRHook)
END_BL_PROP_MAP()

IMPLEMENT_MY_CONTEXT(CRHook, "RHook", "RHook", 1, NULL, NULL, -1);
//.<destination> Объект типа RHook позволяет перехватывать момент уничтожения своего экземпляра и выполнять указанный 
//.скрипт на внутреннем языке V7 в контексте выполняемого модуля. Таким образом RHook позволяет предпринять какие-либо 
//.действия в момент возникновения ошибки (что лучше делает конструкция Попытка-Исключение) и в момент прерывания 
//.выполнения работы модуля пользователем нажатием кнопки 'Esc' (чего стандартными средствами сделать невозможно). 
//.Кроме того RHook позволяет отменить возможность прерывания модуля пользователем нажатием кнопки 'Esc'. 
//.<destination>Это может быть полезно в случаях, когда вмешательство пользователя крайне нежелательно. 
//.<sample>Процедура Сформировать()
//.<sample>	лХук=СоздатьОбъект("RHook");
//.<sample>	лХук.УстановитьПерехватЭскейп(1);
//.<sample>	// пользователь не сможет прервать выполнение этого цикла
//.<sample>	Для А=1 По 20000 Цикл
//.<sample>		Состояние("Цикл 1");
//.<sample>	КонецЦикла;
//.<sample>	лХук.УстановитьПерехватЭскейп(0);
//.<sample>	// а этого сможет
//.<sample>	Для А=1 По 20000 Цикл
//.<sample>		Состояние("Цикл 2");
//.<sample>	КонецЦикла;
//.<sample>КонецПроцедуры

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRHook::CRHook()
{
	m_Hook = FALSE;
	m_Batch = "Hook()";
	m_HookEsc = FALSE;
	hHook = NULL;
	mod = (CBLModule7*)CBLModule7::GetExecutedModule();
}

CRHook::~CRHook()
{
	::UnhookWindowsHookEx(hHook);
	if(m_Hook)
	{
		m_Hook = FALSE;
		if(mod->IsProcessBroken())
		{
			mod->ExecuteBatch(m_Batch, NULL);
		}
		else
		{
			long lId = CBLModule::GetFirstLoadedModuleID();
			mod = (CBLModule7*)CBLModule::GetLoadedModule(lId);
			if(mod)
				mod->ExecuteBatch(m_Batch, NULL);
		}
	};
}

BOOL CRHook::funcSet(CValue& RetVal, CValue **params)
{
	RetVal = m_Hook;
	if(params[0]->GetNumeric() != -1) m_Hook = params[0]->GetNumeric();
	if(params[1]->GetNumeric() != -1) m_Batch = params[1]->GetString();
	
	return TRUE;
}

BOOL CRHook::funcScript(CValue& RetVal, CValue **params)
{
	RetVal = m_Batch;
	if(!params[0]->IsEmpty()) m_Batch = params[0]->GetString();
	
	return TRUE;
}

BOOL CRHook::funcSetHookEsc(CValue& RetVal, CValue **params)
{
	RetVal = m_HookEsc;
	if(params[0]->GetNumeric() != -1) 
	{
		m_HookEsc = params[0]->GetNumeric();
		if(m_HookEsc && (!hHook))
		{
			hHook = ::SetWindowsHookEx(WH_KEYBOARD, EscHook, ::GetModuleHandle(NULL), ::GetCurrentThreadId());
		};
		if((!m_HookEsc) && hHook)
		{
			::UnhookWindowsHookEx(hHook);
			hHook = NULL;
		};
	};
	
	return TRUE;
}

BOOL CRHook::DefaultValue(int nParam, CValue* param) const
{
	*param = -1;
	//*param = CDate(0,0,0);
	return TRUE;
}

