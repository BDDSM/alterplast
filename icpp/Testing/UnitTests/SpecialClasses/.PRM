
///<namespace name = "Классы общего назначения">
///<class name = "ОбщиеМетоды">
Класс ОбщиеМетоды = ОбщиеМетоды.txt
{
	///<method name = "Сравнить" Тип = "Число">
	///<Синтаксис>Сравнить(П1, П2)</Синтаксис>
	///<param name = "П1">Первое значения для сравнения</param>
	///<param name = "П2">Второе значения для сравнения</param>
	///<returns type = "Число"> 1 если значения совпадают, 0 - если не совпадают.</returns>
	///<Описание> Сравнивает П1 и П2 на предмет равенства. Если типы различны, то не равно. 
	///Если П1 и П2 - строки, то они обрезаются справа</Описание>
	///<sig>
	Число Сравнить(Неопределеный П1, Неопределеный П2);
	///</sig>
	///</method>
	
	///<method name = "ПоследнееНепустое" Тип = "Неопределенный">
	///<Синтаксис>ПоследнееНепустое(Значение1, Значение2, ... , ЗначениеN)</Синтаксис>
	///<Описание>Возвращает последний непустой из переданных параметров</Описание>
	///<sig>
	Неопределенный ПоследнееНепустое(...);
	///</sig>
	///</method>

	///<method name = "СтрНайти" Тип = "Число">
	///<Синтаксис>СтрНайти(Где, Что, [НачПоз])"</Синтаксис>
	///<Описание>Ищет строку "Что" в строке "Где", начиная с позиции "НачПоз".</Описание>
	///<param name = "Где">Строка, в которой производится поиск</param>
	///<param name = "Что">Строка, которая ищется. Может быть списком значений - в этом случае проверяются все строки из списка, и возвращается наименьшая найденная позиция.</param>
	///<param name = "НачПоз">Начальная позиция в строке "Где", с которой нужно искать подстроку. Необязательный парамтер, по умолчанию = 1.</param>
	///<sig>
	Число СтрНайти(Строка Где, Неопределенный Что, Число НачПоз = 1);
	///</sig>
	///</method>
	
	///<method name = "СтрПовторить" Тип = "Строка">
	///<Синтаксис>СтрПовторить(Фрагмент, Количество)</Синтаксис>
	///<Описание>Повторяет строку Фрагмент указанное количество раз.</Описание>
	///<returns type = "Строка"></returns>
	///<sig>
	Строка СтрПовторить(Строка Фрагмент, Знач Число Количество);
	///</sig>
	///</method>
	
	///<method name = "СтрокуВСписок" Тип = "СписокЗначений">
	///<Синтаксис>СтрокуВСписок(Строка, [Разделитель], [ОбрезатьПробелы])</Синтаксис>
	///<Описание>Преобразует сроку с разделителями в список строк (СписокЗначений).</Описание>
	///<param name = "Строка">Преобразуемая строка</param>
	///<param name = "Разделитель">Строка или список строк (СписокЗначений), используемые в качестве разделителя подстрок. По умолчанию ","</param>
	///<param name = "ОбрезатьПробелы">Если 1, то в каждой строке результирующего списка будут обрезаны пробелы. Например: строка " Апельсин  , Яблоко" будет преобразована в список{"Апельсин", "Яблоко"}.
	///По умолчанию - 0.</param>
	///<Пример>
	///Разделители = СоздатьОбъект("СписокЗначений");
	///Разделители.ДобавитьЗначение(",");
	///Разделители.ДобавитьЗначение(";");
	///Разделители.ДобавитьЗначение(":");
	///Сп = СтрокуВСписок(" Апельсин  , Яблоко; Мандарин: Ананас", Разделители, 1);
	///возвращает список {"Апельсин", "Яблоко", "Мандарин", "Ананас"}
	///</Пример>
	///<sig>
	СписокЗначений СтрокуВСписок(Знач Строка Стр, Неопределенный Разделитель = ",", Число ОбрезатьПробелы = 0);
	///</sig>
	///</method>
	
	///<method name = "СписокВСтроку" Тип = "Строка">
	///<Синтаксис>СписокВСтроку(СписокЗначений, [Разделитель], [ВключатьПустыеЗначения])</Синтаксис>
	///<Описание>Преобразует список в строку. Каждое значение списка преобразуется в строку по своему представлению. Значения отделяются друг от друга указанным разделителем.</Описание>
	///<param name = "СписокЗначений">Список, который нужно преобразовать в строку.</param>
	///<param name = "Разделитель">Строка - разделитель значений. По умолчанию - ","</param>
	///<param name = "ВключатьПустыеЗначения">Если 1, то в итоговую строку будут включены все значения из списка. Если 0, то в строку будут включены только непустые значения (т.е. вместо "Знач1,,Знач3" получим "Знач1,Знач3").</param>
	///<sig>
	Строка СписокВСтроку(СписокЗначений Сп, Строка Разделитель = ",", Число ВключатьПустыеЗначения = 1);
	///</sig>
	///</method>
	
	///<method name = "РазницаДат" Тип = "Число">
	///<Синтаксис>РазницаДат(Дата1, Дата2, [Лет], [Мес], [Дней])</Синтаксис>
	///<Описание>Возвращает количество полных месяцев в интервале [Дата1, Дата2]. Если указаны параметры Лет, Мес и Дней, то в них записываются соотв. значения разницы. Например '12.02.2001' - '01.01.2000' = 1 лет, 1 мес. и 12 дней.</Описание>
	///<param name = "Дата1">Дата начала периода</param>
	///<param name = "Дата2">Дата окончания периода</param>
	///<sig>
	Число РазницаДат(Дата Дата1, Дата Дата2, Неопределенный Лет, Неопределенный Мес, Неопределенный Дней);
	///</sig>
	///</method>
	
	///<method name = "ПересечениеПериодов" Тип = "Число">
	///<Синтаксис>ПересечениеПериодов(НП1, КП1, НП2, КП2, [ПересечениеНач], [ПересечениеКон])</Синтаксис>
	///<Описание>Вычисляет границы пересечения двух периодов. Периоды могут быть открытыми (т.е. одна или обе границы периода не заданы). Вычисленные границы возвращаются в параметрах ПересечениеНач и ПересечениеКон.</Описание>
	///<returns type = "Число">Если периоды пересекаются, то 1, в противном случае - 0.</returns>
	///<param name = "НП1">Дата начала первого периода</param>
	///<param name = "КП1">Дата окончания первого периода</param>
	///<param name = "НП2">Дата начала второго периода</param>
	///<param name = "КП2">Дата окончания второго периода</param>
	///<param name = "ПересечениеНач" mod = "out">Дата начала пересечения периодов</param>
	///<param name = "ПересечениеКон" mod = "out">Дата окончания пересечения периодов</param>
	///<sig>
	//Пересечение периодов {НП1, КП1} {НП2, КП2}. {ПересечениеНач, ПересечениеКон} - границы пересечения
	//Возвращает 1 если периоды пересекаются, 0 - в противном случае
	Число ПересечениеПериодов(НП1, КП1, НП2, КП2, ПересечениеНач="", ПересечениеКон="");
	///</sig>
	///</method>
	
	///<method name = "ДатаИзСтроки" Тип = "Дата">
	///<Синтаксис>ДатаИзСтроки(Строка)</Синтаксис>
	///<Описание>Пытается расшифровать дату, заданную в виде строки.</Описание>
	///<returns type = "Дата">Дешифрованная дата</returns>
	///<sig>
	Дата ДатаИзСтроки(Знач Строка стрДата);
	///</sig>
	///</method>
	
	///<method name = "ФильтрЗначения" Тип = "Число">
	///<Синтаксис>ФильтрЗначения(Значение, Значение1, Значение2)</Синтаксис>
	///<Описание>Для чисел и дат проверяет, попадает ли Значение в интервал {Значение1, Значение2}. Для всех остальных типов проверяет, равно ли Значение параметру Значение1. Если типы параметров Значение, Значение1 и Значение2 не совпадают, то все параметры преобразуются в строки по своим представлениям, и сравниваются литерально.
	///Дополнительные особенности сравнения значений для разных типов:
	/// - Справочник, Счет - если Значени1 - группа, то проверяется вхождение Значение в группу Значение1;
	/// - Значение1 является списком значений или таблицей значений - производится поиск Значение во всём списке или таблице.
	///</Описание>
	///<param name = "Значение">Тестируемое значение</param>
	///<param name = "Значение1">Левая граница интервала</param>
	///<param name = "Значение2">Правая граница интервала</param>
	///<sig>
	Число ФильтрЗначения(Знач Неопределенный Значение, Знач Неопределенный Знач1, Знач Неопределенный Знач2);
	///</sig>
	///</method>
	
	///<method name = "ОткрытьОбработку" Тип = "Число">
	///<Синтаксис>ОткрытьОбработку(ИмяОбработки, Параметры, [Модально], [Внешняя], [QuietMode])</Синтаксис>
	///<Описание>Пытается открыть обработку, отчет или внешний отчет с указанным именем. Последовательность поиска:
	/// @Если функция вызвана из внешнего отчета
	///   1) Внешний отчет в том же каталоге, что и вызывающий отчет (если он внешний)
	///   2) Внешний отчет в каталоге базы данных
	///   3) Внешний отчет в каталоге ExtForms
	///   4) Обработка
	///   5) Отчет
	/// @Если функция вызвана из объекта конфигурации
	///   1) Обработка
	///   2) Отчет
	///   3) Внешний отчет в том же каталоге, что и вызывающий отчет (если он внешний)
	///   4) Внешний отчет в каталоге базы данных
	///   5) Внешний отчет в каталоге ExtForms
	///</Описание>
	///<returns type = "Число">Если отчет/обработка открыт успешно, то 1, в противном случае - 0.</returns>
	///<param name = "ИмяОбработки">строка с именем обработки/отчета. Без пути и расширения. Если последний символ имени обработки - "#", то обработка откроется в новом окне.</param>
	///<param name = "Параметры">Это значение будет передано в качестве параметра в обработку.</param>
	///<param name = "Модально">Если 1, то форма будет открыта модально. По умолчанию 0.</param>
	///<param name = "Внешняя">Если 1, то сначала будет произведен поиск внешней обработки, и только в случае неуспеха - обработки/отчета в конфигурации.
	/// Если в этом параметре передана Строка или СписокЗначений, то они рассматривается как имя каталога, в котором нужно поискать первым делом.</param>
	///<sig>
	Неопределенный ОткрытьОбработку(Строка ИмяОбработки, Знач Неопределенный Параметры, Число Модально = 0, Знач Неопределенный Внешняя = 0, Число QuietMode = 0);
	///</sig>
	///</method>
	
	///<method name = "ЯвляетсяПроизводнымОт" Тип = "Число">
	///<Синтаксис>ЯвляетсяПроизводнымОт(ЭкземплярКласса, ИмяБазовогоКласса)</Синтаксис>
	///<Описание>Возвращает 1, если ЭкземплярКласса является производным от класса ИмяБазовогоКласса.</Описание>
	///<param name = "ЭкземплярКласса">Тестируемый экземпляр класса (объект, созданный методом СоздатьОбъект(ИмяКласса)).</param>
	///<param name = "ИмяБазовогоКласса">Строка с именем базового класса.</param>
	///<sig>
	Число ЯвляетсяПроизводнымОт(Неопределенный ЭкземплярКласса, Строка ИмяБазовогоКласса);
	///</sig>
	///</method>
	
	///<method name = "ПолучитьВызывающийКонтекст" Тип = "ГрупповойКонтекст">
	///<Синтаксис>ПолучитьВызывающийКонтекст(Контекст)</Синтаксис>
	///<Описание>Определяет вызывающий контекст. Предназначен для использования в производных классах, когда метод ПолучитьКонтекстОкружения() возвращает контекст родительского класса.</Описание>
	///<param name = "Контекст">Текущий контекст вызова метода.</param>
	///<sig>
	Неопределенный ПолучитьВызывающийКонтекст(Неопределенный Контекст);
	///</sig>
	///</method>
};
///</class>
